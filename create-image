#!/bin/bash

# Setup script error handling see https://disconnected.systems/blog/another-bash-strict-mode for details
set -xuo pipefail
trap 's=$?; echo "$0: Error on line "$LINENO": $BASH_COMMAND"; exit $s' ERR
IFS=$'\n\t'

# Ensure we are root
if [[ $EUID -ne 0 ]]; then
    echo "This script must be run as root" 1>&2
    exit 1
fi

# Some useful constants
image="opm.img"
mount="mnt"
script="setup"
rpi_zip="2017-07-05-raspbian-jessie-lite.zip"
rpi_url="http://downloads.raspberrypi.org/raspbian_lite/images/raspbian_lite-2017-07-05/${rpi_zip}"

# Unmount drives and general cleanup on exit, the trap ensures this will always
# run execpt in the most extream cases.
cleanup() {
    [[ -f "${mount}/tmp/${script}" ]] && rm "${mount}/tmp/${script}"
    if [[ -d "${mount}" ]]; then
#        rm "${mount}/etc/ld.so.preload"
#        mv "${mount}/etc/_ld.so.preload" "${mount}/etc/ld.so.preload"
        umount "${mount}/dev/pts" || true
        umount "${mount}/dev" || true
        umount "${mount}/proc" || true
        umount "${mount}/sys" || true
        umount "${mount}/boot" || true
        umount "${mount}" || true
        rmdir "${mount}" || true
    fi
    [ -n "${loopdev:-}" ] && losetup --detach "${loopdev}" || true
}
trap cleanup EXIT

# Grab the first two arguments, using the defaults if not set
# This allows running the command as any of
#   ./create-image                 # to use the defaults
#   ./create-image 4G              # create a 4 gig image instead of 2 gig
#   ./create-image 4G myname.img   # create a 4 gig image called myname.img
#size="${1:-2G}"
#image="${2:-image.img}"

# Download raspbian arm only if we have not already done so
[ ! -f "${rpi_zip}" ] && wget "${rpi_url}"

# Clean the existing image files
(ls *.img >> /dev/null 2>&1 && rm *.img) || echo "no .img files to remove"

# Unzip Raspbian
# -u  update files, create if necessary
unzip -u "${rpi_zip}"

mv "$(ls *.img | head -n 1)" "${image}"

# Get sector size of the image file
secsize=$(fdisk -l $image | grep "Sector size" | sed -r "s/[^0-9]*([0-9]+).*/\1/")
echo "Sector size: $secsize"

# Get the start sectors for both partitions
start1=$(fdisk -l $image | grep ".img1" | sed -r "s/[^0-9]*[0-9][^0-9]*([0-9]+).*/\1/")
start2=$(fdisk -l $image | grep ".img2" | sed -r "s/[^0-9]*[0-9][^0-9]*([0-9]+).*/\1/")
echo "Part 1 start: $start1"
echo "Part 2 start: $start2"

# Calculate offset in bytes for both partitions
off1="$(($secsize*$start1))"
off2="$(($secsize*$start2))"
echo "Offset P1: $off1 bytes"
echo "Offset P2: $off2 bytes"

# Add 1G to the image size
dd if=/dev/zero bs=1M count=1024 >> "${image}"

# Configure loopback device to expand partition 2
loopdev=$(losetup --find --show "${image}")
echo "Created loopback device ${loopdev}"

parted --script "${loopdev}" print
#arted --script "${loopdev}" rm 2
#parted --script "${loopdev}" mkpart primary "${off2}B" 100%
parted --script "${loopdev}" resizepart 2 100%
parted --script "${loopdev}" print

e2fsck -f "${loopdev}p2"
resize2fs "${loopdev}p2"

# Clean up loopback device
losetup -d "${loopdev}"

echo "Finished resizing disk image."

# Mount the image file
#mkdir "${mount}"
#mount -o loop,offset="${off2}" "${image}" "${mount}"
#mount -o loop,offset="${off1}" "${image}" "${mount}/boot"

loopdev=$(losetup --find --show "${image}")
bootdev=$(ls "${loopdev}"*1)
rootdev=$(ls "${loopdev}"*2)
partprobe "${loopdev}"

# Mount the image
[ ! -d "${mount}" ] && mkdir "${mount}"
mount "${rootdev}" "${mount}"
[ ! -d "${mount}/boot" ] && mkdir "${mount}/boot"
mount "${bootdev}" "${mount}/boot"

# Copy our installtion script and other artifacts
install -Dm755 "${script}" "${mount}/tmp/${script}"

# Prep the chroot
mount --bind /proc "${mount}/proc"
mount --bind /sys "${mount}/sys"
mount --bind /dev "${mount}/dev"
mount --bind /dev/pts "${mount}/dev/pts"
rm "${mount}/etc/resolv.conf"
cp /etc/resolv.conf "${mount}/etc/resolv.conf"
cp /usr/bin/qemu-arm-static "${mount}/usr/bin"
mv "${mount}/etc/ld.so.preload" "${mount}/etc/_ld.so.preload"
touch "${mount}/etc/ld.so.preload"

# We need to get the new PARTUUID for /boot/cmdline.txt and /etc/fstab.
# Parted changes the PARTUUID fo the disk image, we need to get the new one.
echo "Setting up new partuuid."
blkid "${loopdev}p1"
blkid "${loopdev}p2"
partuuid=$(blkid "${loopdev}" | sed -r 's/.**PTUUID=\"([a-zA-Z0-9]*).*/\1/')
echo "New partuuid: ${partuuid}"

echo "cmdline.txt before:"
cat "${mount}/boot/cmdline.txt"
sed -i "s/PARTUUID=[a-zA-Z0-9]*/PARTUUID=${partuuid}/" "${mount}/boot/cmdline.txt"
echo "cmdline.txt after:"
cat "${mount}/boot/cmdline.txt"

echo "fstab before:"
cat "${mount}/etc/fstab"
sed -i "s/PARTUUID=[a-zA-Z0-9]*/PARTUUID=${partuuid}/g" "${mount}/etc/fstab"
echo "fstab after:"
cat "${mount}/etc/fstab"

chroot "${mount}" "/tmp/${script}"

mv "${mount}/etc/_ld.so.preload" "${mount}/etc/ld.so.preload"
